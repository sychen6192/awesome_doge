{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"/Users/sychen/thesis-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _asyncToGenerator = require(\"/Users/sychen/thesis-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _regeneratorRuntime = require(\"/Users/sychen/thesis-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncIterator = require(\"/Users/sychen/thesis-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar multibase = require('multibase');\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar log = require('debug')('ipfs-http-client:pubsub:subscribe');\n\nvar SubscriptionTracker = require('./subscription-tracker');\n\nvar configure = require('../lib/configure');\n\nvar toUrlSearchParams = require('../lib/to-url-search-params');\n\nmodule.exports = configure(function (api, options) {\n  var subsTracker = SubscriptionTracker.singleton();\n\n  var publish = require('./publish')(options);\n\n  return /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(topic, handler) {\n      var options,\n          res,\n          ffWorkaround,\n          _args3 = arguments;\n      return _regeneratorRuntime.wrap(function _callee2$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              options = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};\n              options.signal = subsTracker.subscribe(topic, handler, options.signal);\n              // In Firefox, the initial call to fetch does not resolve until some data\n              // is received. If this doesn't happen within 1 second send an empty message\n              // to kickstart the process.\n              ffWorkaround = setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                return _regeneratorRuntime.wrap(function _callee$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        log(\"Publishing empty message to \\\"\".concat(topic, \"\\\" to resolve subscription request\"));\n                        _context2.prev = 1;\n                        _context2.next = 4;\n                        return publish(topic, Buffer.alloc(0), options);\n\n                      case 4:\n                        _context2.next = 9;\n                        break;\n\n                      case 6:\n                        _context2.prev = 6;\n                        _context2.t0 = _context2[\"catch\"](1);\n                        log('Failed to publish empty message', _context2.t0);\n\n                      case 9:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee, null, [[1, 6]]);\n              })), 1000);\n              _context3.prev = 3;\n              _context3.next = 6;\n              return api.post('pubsub/sub', {\n                timeout: options.timeout,\n                signal: options.signal,\n                searchParams: toUrlSearchParams(_objectSpread({\n                  arg: topic\n                }, options)),\n                headers: options.headers\n              });\n\n            case 6:\n              res = _context3.sent;\n              _context3.next = 13;\n              break;\n\n            case 9:\n              _context3.prev = 9;\n              _context3.t0 = _context3[\"catch\"](3);\n              // Initial subscribe fail, ensure we clean up\n              subsTracker.unsubscribe(topic, handler);\n              throw _context3.t0;\n\n            case 13:\n              clearTimeout(ffWorkaround);\n              readMessages(res.ndjson(), {\n                onMessage: handler,\n                onEnd: function onEnd() {\n                  return subsTracker.unsubscribe(topic, handler);\n                },\n                onError: options.onError\n              });\n\n            case 15:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee2, null, [[3, 9]]);\n    }));\n\n    return function (_x, _x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n});\n\nfunction readMessages(msgStream, _ref) {\n  var onMessage = _ref.onMessage,\n      onEnd = _ref.onEnd,\n      onError = _ref.onError;\n\n  var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, msg;\n\n  return _regeneratorRuntime.async(function readMessages$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          onError = onError || log;\n          _context.prev = 1;\n          _iteratorNormalCompletion = true;\n          _didIteratorError = false;\n          _context.prev = 4;\n          _iterator = _asyncIterator(msgStream);\n\n        case 6:\n          _context.next = 8;\n          return _regeneratorRuntime.awrap(_iterator.next());\n\n        case 8:\n          _step = _context.sent;\n          _iteratorNormalCompletion = _step.done;\n          _context.next = 12;\n          return _regeneratorRuntime.awrap(_step.value);\n\n        case 12:\n          _value = _context.sent;\n\n          if (_iteratorNormalCompletion) {\n            _context.next = 19;\n            break;\n          }\n\n          msg = _value;\n\n          try {\n            onMessage({\n              from: multibase.encode('base58btc', Buffer.from(msg.from, 'base64')).toString().slice(1),\n              data: Buffer.from(msg.data, 'base64'),\n              seqno: Buffer.from(msg.seqno, 'base64'),\n              topicIDs: msg.topicIDs\n            });\n          } catch (err) {\n            err.message = \"Failed to parse pubsub message: \".concat(err.message);\n            onError(err, false, msg); // Not fatal\n          }\n\n        case 16:\n          _iteratorNormalCompletion = true;\n          _context.next = 6;\n          break;\n\n        case 19:\n          _context.next = 25;\n          break;\n\n        case 21:\n          _context.prev = 21;\n          _context.t0 = _context[\"catch\"](4);\n          _didIteratorError = true;\n          _iteratorError = _context.t0;\n\n        case 25:\n          _context.prev = 25;\n          _context.prev = 26;\n\n          if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n            _context.next = 30;\n            break;\n          }\n\n          _context.next = 30;\n          return _regeneratorRuntime.awrap(_iterator.return());\n\n        case 30:\n          _context.prev = 30;\n\n          if (!_didIteratorError) {\n            _context.next = 33;\n            break;\n          }\n\n          throw _iteratorError;\n\n        case 33:\n          return _context.finish(30);\n\n        case 34:\n          return _context.finish(25);\n\n        case 35:\n          _context.next = 40;\n          break;\n\n        case 37:\n          _context.prev = 37;\n          _context.t1 = _context[\"catch\"](1);\n\n          // FIXME: In testing with Chrome, err.type is undefined (should not be!)\n          // Temporarily use the name property instead.\n          if (_context.t1.type !== 'aborted' && _context.t1.name !== 'AbortError') {\n            onError(_context.t1, true); // Fatal\n          }\n\n        case 40:\n          _context.prev = 40;\n          onEnd();\n          return _context.finish(40);\n\n        case 43:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[1, 37, 40, 43], [4, 21, 25, 35], [26,, 30, 34]], Promise);\n}","map":{"version":3,"sources":["/Users/sychen/thesis-app/node_modules/ipfs-http-client/src/pubsub/subscribe.js"],"names":["multibase","require","Buffer","log","SubscriptionTracker","configure","toUrlSearchParams","module","exports","api","options","subsTracker","singleton","publish","topic","handler","signal","subscribe","ffWorkaround","setTimeout","alloc","post","timeout","searchParams","arg","headers","res","unsubscribe","clearTimeout","readMessages","ndjson","onMessage","onEnd","onError","msgStream","msg","from","encode","toString","slice","data","seqno","topicIDs","err","message","type","name"],"mappings":"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","sourcesContent":["'use strict'\n\nconst multibase = require('multibase')\nconst { Buffer } = require('buffer')\nconst log = require('debug')('ipfs-http-client:pubsub:subscribe')\nconst SubscriptionTracker = require('./subscription-tracker')\nconst configure = require('../lib/configure')\nconst toUrlSearchParams = require('../lib/to-url-search-params')\n\nmodule.exports = configure((api, options) => {\n  const subsTracker = SubscriptionTracker.singleton()\n  const publish = require('./publish')(options)\n\n  return async (topic, handler, options = {}) => {\n    options.signal = subsTracker.subscribe(topic, handler, options.signal)\n\n    let res\n\n    // In Firefox, the initial call to fetch does not resolve until some data\n    // is received. If this doesn't happen within 1 second send an empty message\n    // to kickstart the process.\n    const ffWorkaround = setTimeout(async () => {\n      log(`Publishing empty message to \"${topic}\" to resolve subscription request`)\n      try {\n        await publish(topic, Buffer.alloc(0), options)\n      } catch (err) {\n        log('Failed to publish empty message', err)\n      }\n    }, 1000)\n\n    try {\n      res = await api.post('pubsub/sub', {\n        timeout: options.timeout,\n        signal: options.signal,\n        searchParams: toUrlSearchParams({\n          arg: topic,\n          ...options\n        }),\n        headers: options.headers\n      })\n    } catch (err) { // Initial subscribe fail, ensure we clean up\n      subsTracker.unsubscribe(topic, handler)\n      throw err\n    }\n\n    clearTimeout(ffWorkaround)\n\n    readMessages(res.ndjson(), {\n      onMessage: handler,\n      onEnd: () => subsTracker.unsubscribe(topic, handler),\n      onError: options.onError\n    })\n  }\n})\n\nasync function readMessages (msgStream, { onMessage, onEnd, onError }) {\n  onError = onError || log\n\n  try {\n    for await (const msg of msgStream) {\n      try {\n        onMessage({\n          from: multibase.encode('base58btc', Buffer.from(msg.from, 'base64')).toString().slice(1),\n          data: Buffer.from(msg.data, 'base64'),\n          seqno: Buffer.from(msg.seqno, 'base64'),\n          topicIDs: msg.topicIDs\n        })\n      } catch (err) {\n        err.message = `Failed to parse pubsub message: ${err.message}`\n        onError(err, false, msg) // Not fatal\n      }\n    }\n  } catch (err) {\n    // FIXME: In testing with Chrome, err.type is undefined (should not be!)\n    // Temporarily use the name property instead.\n    if (err.type !== 'aborted' && err.name !== 'AbortError') {\n      onError(err, true) // Fatal\n    }\n  } finally {\n    onEnd()\n  }\n}\n"]},"metadata":{},"sourceType":"script"}